# 简易编译器前端实现

---

### 一、词法分析

`token.txt`文件描述了语言中包含的有意义的词法单元。

`Lexer`类进行词法分析实现，通过字符串扫描将源代码转化为token序列：

- 1、首先处理单行注释和多行注释：

对于单行注释，当匹配到`//`时，向后扫描直至遇到`\n`，然后删去单行注释。

对于多行注释，当匹配到`/*`时，向后扫描直至遇到`*/`，然后删去多行注释。注意，多行注释中的换行符`\n`需要保留，以便确定每个token所在行数，编译器报错时可以将错误所在行数显示出来。

- 2、然后通过Java中的`String.split()`方法，将删去注释后的源代码通过`\n`分隔开，每行分别进行词法分析。

- 3、对于每行的代码，再调用`String.split()`，将其通过`[ \t]`分隔开，这样得到的每个代码片段中就不再包含空格、换行符和制表符。

- 4、对于每个代码片段，根据`token.txt`中定义的有意义的词法单元，通过字符串扫描进行词法分析。

---

### 二、语法分析、语义分析和中间代码生成

当文法为LL(1)文法，且SDD为L属性时，语义分析和中间代码生成可以在语法分析阶段一并进行。

- 1、`SDT.txt`定义了语言的语法制导的翻译方案。文法中大部分内容满足LL(1) + L-SDD，少部分不满足LL(1)的文法也可以通过对token序列进一步扫描来解决。

- 2、`Parser`类根据SDT进行了语法分析、语义分析和中间代码生成。`Parser.bindLabelWithAddress()`方法通过遍历生成的中间代码将每个跳转指令的标签与目标指令的序号绑定。

- 3、`SymbolTable`为符号表，通过指向外层作用域的`out`指针实现嵌套作用域。

- 4、`IR`类为中间代码的结构化表示，将中间代码表示成包括`op`、`arg1`、`arg2`和`result`四个部分的四元式形式。

---

### 三、中间代码优化

`IROptimizer`类用于优化生成的中间代码，包含常量折叠、常量传播和冗余跳转指令消除。

- 1、常量折叠：能够直接计算的常量的加减乘除，直接计算出来。如`t = 2 + 3`，`2 + 3`可以直接计算出来，所以这条指令可以被优化为`t = 5`。

- 2、常量传播：对于值为固定常量的临时变量，对其赋值的指令应当被删除，并在后面使用该临时变量的指令中，将该临时变量替换未其值。如：

```
0: t1 = 3
1: t2 = t1
2: t3 = t2 + i
```

第0条指令应当删除，并将后面指令中的`t1`替换为`3`：

```
1: t2 = 3
2: t3 = t2 + i
```

进一步地，第1条指令应当被删除，并将后面指令中的`t2`替换为`3`：

```
2: t3 = 3 + i
```

- 3、冗余跳转指令消除：当某条指令是无条件跳转指令，且这条指令的前一条指令也是无条件跳转指令时，该跳转指令为冗余跳转指令，应当删除。如：

```
9: goto 10
10: goto 20
```

第10条指令应当删除，并将第9条指令中的`10`替换为`20`：

```
9: goto 20
```

---

### 四、测试

`test_source_code.txt`为测试源代码，`intermediate_representation.txt`为编译器解析测试源代码生成的中间代码。
